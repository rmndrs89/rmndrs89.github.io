[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "projects/20231016_ecological_validity/index.html",
    "href": "projects/20231016_ecological_validity/index.html",
    "title": "Ecological validity of a deep learning algorithm for gait events detection",
    "section": "",
    "text": "Abstract\n\n\n\nThe clinical assessment of mobility, and walking specifically, is mainly based on functional tests that lack ecological validity. Thanks to inertial measurement units (IMUs), gait analysis is shifting to unsupervised monitoring in naturalistic and unconstrained settings. We have developed a deep learning (DL) algorithm for gait event detection in a heterogeneous population of different mobility-limiting diseases. The results showed a high detection performance for initial contacts (ICs) (recall: 98%, precision: 96%) and final contacts (FCs) (recall: 99%, precision: 94%) and a maximum median time error of $-$0.02 s for ICs and 0.03 s for FCs."
  },
  {
    "objectID": "talks/20260106_first_talk/index.html#a-note-of-history",
    "href": "talks/20260106_first_talk/index.html#a-note-of-history",
    "title": "The Curious Case of Thomas Bayes",
    "section": "A note of history",
    "text": "A note of history\n“Traditional” statistics (Dienes 2011)"
  },
  {
    "objectID": "talks/20260106_first_talk/index.html#bayesian-statistics",
    "href": "talks/20260106_first_talk/index.html#bayesian-statistics",
    "title": "The Curious Case of Thomas Bayes",
    "section": "Bayesian statistics",
    "text": "Bayesian statistics\n\n\n\n\n\n\nPlausibility\n\n\nBayesian statistics starts from the premise that we can assign degrees of plausibility to theories, and what we want our data to do is to tell us how to adjust these plausibilities.\n– Dienes (2011)\n\n\n\n\\[\n\\text{Pr}(\\text{hypothesis} \\mid \\text{data})\n\\]"
  },
  {
    "objectID": "talks/20260106_first_talk/index.html#getting-up",
    "href": "talks/20260106_first_talk/index.html#getting-up",
    "title": "The Curious Case of Thomas Bayes",
    "section": "Getting up",
    "text": "Getting up\n\nTurn off alarm\nGet out of bed"
  },
  {
    "objectID": "talks/20260106_first_talk/index.html#going-to-sleep",
    "href": "talks/20260106_first_talk/index.html#going-to-sleep",
    "title": "The Curious Case of Thomas Bayes",
    "section": "Going to sleep",
    "text": "Going to sleep\n\nGet in bed\nCount sheep"
  },
  {
    "objectID": "talks/20260106_first_talk/index.html#code-blocks",
    "href": "talks/20260106_first_talk/index.html#code-blocks",
    "title": "The Curious Case of Thomas Bayes",
    "section": "Code blocks",
    "text": "Code blocks\n\n\nFigure 1: Distributions of IQ for the two groups."
  },
  {
    "objectID": "talks/20260106_first_talk/index.html#the-illusion-of-objectivity",
    "href": "talks/20260106_first_talk/index.html#the-illusion-of-objectivity",
    "title": "The Curious Case of Thomas Bayes",
    "section": "The Illusion of Objectivity",
    "text": "The Illusion of Objectivity\n\nGoal: determine the effectiveness of vitamin C in treating the common cold (Berger and Berry. 1988)\nHypothesis: vitamin C has no effect on the common cold (“null hypothesis”)\nExperiment: 17 matched pairs\n\nC: subject receives vitamin C\nP: subject receives placebo\n\nOutcome: does the subjecting receiving C or the subject receiving P exhibit greater relief after treatment?\nResults:\n\n13 pairs: C is better\n4 pairs: P is better"
  },
  {
    "objectID": "talks/20260106_first_talk/index.html#explore-the-results-space",
    "href": "talks/20260106_first_talk/index.html#explore-the-results-space",
    "title": "The Curious Case of Thomas Bayes",
    "section": "Explore the results space",
    "text": "Explore the results space"
  },
  {
    "objectID": "talks/20260106_first_talk/index.html#discussion",
    "href": "talks/20260106_first_talk/index.html#discussion",
    "title": "The Curious Case of Thomas Bayes",
    "section": "Discussion",
    "text": "Discussion\n\nObserving 13 preferences for C is somewhat unexpected when H is true\nProof by contradiction\n\nAssume that H is true, and find a consequence R that logically follows from H yet is known to be false\n\nThis contradiction shows that H cannot be true\n\nIn standard statistics:\n\nH is the null hypothesis\nR is the observed or more extreme values\n\n\n\\(p\\) = 0.049"
  },
  {
    "objectID": "talks/20260106_first_talk/index.html#references",
    "href": "talks/20260106_first_talk/index.html#references",
    "title": "The Curious Case of Thomas Bayes",
    "section": "References",
    "text": "References\n\n\nBerger, James O., and Donald A. Berry. 1988. “Statistical Analysis and the Illusion of Objectivity.” American Scientist 76 (2): 159–65.\n\n\nDienes, Zoltan. 2011. “Bayesian Versus Orthodox Statistics: Which Side Are You On?” Perspectives on Psychological Science 6 (3): 274–90. https://doi.org/10.1177/1745691611406920."
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Blog",
    "section": "",
    "text": "My first post\n\n\n\nPython\n\nTensorFlow\n\n\n\nMy first blog post.\n\n\n\n\n\nOct 12, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Robbin Romijnders",
    "section": "",
    "text": "Tip\n\n\n\nI am currently rebuilding my personal website using Quarto, so you won’t see that much here yet.\n\n\nI am a biomedical engineer with expertise in digital signal processing and machine learning.\nMy core experience involves the analysis of complex, multimodal longitudinal datasets to understand dynamic physiological and health processes.\nA crucial part of my work is communicating technical findings effectively: I am adept at translating sophisticated results for a diverse audience, ensuring clarity and relevance whether I’m speaking with a fellow engineer or a practicing clinician."
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Robbin Romijnders",
    "section": "",
    "text": "Tip\n\n\n\nI am currently rebuilding my personal website using Quarto, so you won’t see that much here yet.\n\n\nI am a biomedical engineer with expertise in digital signal processing and machine learning.\nMy core experience involves the analysis of complex, multimodal longitudinal datasets to understand dynamic physiological and health processes.\nA crucial part of my work is communicating technical findings effectively: I am adept at translating sophisticated results for a diverse audience, ensuring clarity and relevance whether I’m speaking with a fellow engineer or a practicing clinician."
  },
  {
    "objectID": "talks.html",
    "href": "talks.html",
    "title": "Talks",
    "section": "",
    "text": "The Curious Case of Thomas Bayes\n\n\nWhat is Bayesian analysis and why should you use it?\n\n\n\n\n\nJan 6, 2026\n\n\nRobbin Romijnders\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Ecological validity of a deep learning algorithm for gait events detection\n\n\n\nPython\n\ndigital signal processing\n\nmachine learning\n\n\n\nDetecting gait events from inertial measurement units in the free-living environment.\n\n\n\nRobbin Romijnders\n\n\nOct 16, 2023\n\n\n\n\n\n\n\n\n\n\n\nDigit recognizer\n\n\n\nPython\n\nPyTorch\n\n\n\nRecognizing handwritten digits with a convolutional neural network.\n\n\n\nRobbin Romijnders\n\n\nNov 17, 2021\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/20251112_first_post/index.html",
    "href": "posts/20251112_first_post/index.html",
    "title": "My first post",
    "section": "",
    "text": "Here is my first post!"
  },
  {
    "objectID": "projects/20211117_digit_recognizer/index.html",
    "href": "projects/20211117_digit_recognizer/index.html",
    "title": "Digit recognizer",
    "section": "",
    "text": "Abstract\n\n\n\nThe problem with handwritten digits.\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torch.utils.data import DataLoader\nimport torchvision\nfrom torchvision import datasets, transforms\n\n# Define the data transforms\ndata_transforms = transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize(mean=(0.1307,), std=(0.3081,))\n])\n\n# Get the MNIST dataset\nROOT_PATH = \"~/Datasets/PyTorch\"\ntrain_dataset = torchvision.datasets.MNIST(root=ROOT_PATH, train=True, transform=data_transforms, download=True)\ntest_dataset = torchvision.datasets.MNIST(root=ROOT_PATH, train=False, transform=data_transforms, download=True)\n\n# Define the dataloaders\nBATCH_SIZE = 64\ntrain_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)\ntest_loader = DataLoader(test_dataset, batch_size=BATCH_SIZE, shuffle=False)\n\n# Visualize images\nfor example_images, example_labels in train_loader:\n    break\nnum_cols = 8\nnum_rows = int(example_images.shape[0] // num_cols)\nfig, axs = plt.subplots(num_rows, num_cols, figsize=(5, 5))\nfig.subplots_adjust(wspace=0.05, hspace=0.05)\nfor example_idx in range(example_images.shape[0]):\n    ax = axs[example_idx % num_cols, example_idx // num_cols]\n    ax.imshow(example_images[example_idx].squeeze(), cmap=\"gray\")\n    ax.axis(\"off\")\n# plt.tight_layout()\nplt.show()\n\n\n0.3%0.7%1.0%1.3%1.7%2.0%2.3%2.6%3.0%3.3%3.6%4.0%4.3%4.6%5.0%5.3%5.6%6.0%6.3%6.6%6.9%7.3%7.6%7.9%8.3%8.6%8.9%9.3%9.6%9.9%10.2%10.6%10.9%11.2%11.6%11.9%12.2%12.6%12.9%13.2%13.6%13.9%14.2%14.5%14.9%15.2%15.5%15.9%16.2%16.5%16.9%17.2%17.5%17.9%18.2%18.5%18.8%19.2%19.5%19.8%20.2%20.5%20.8%21.2%21.5%21.8%22.1%22.5%22.8%23.1%23.5%23.8%24.1%24.5%24.8%25.1%25.5%25.8%26.1%26.4%26.8%27.1%27.4%27.8%28.1%28.4%28.8%29.1%29.4%29.8%30.1%30.4%30.7%31.1%31.4%31.7%32.1%32.4%32.7%33.1%33.4%33.7%34.0%34.4%34.7%35.0%35.4%35.7%36.0%36.4%36.7%37.0%37.4%37.7%38.0%38.3%38.7%39.0%39.3%39.7%40.0%40.3%40.7%41.0%41.3%41.7%42.0%42.3%42.6%43.0%43.3%43.6%44.0%44.3%44.6%45.0%45.3%45.6%45.9%46.3%46.6%46.9%47.3%47.6%47.9%48.3%48.6%48.9%49.3%49.6%49.9%50.2%50.6%50.9%51.2%51.6%51.9%52.2%52.6%52.9%53.2%53.6%53.9%54.2%54.5%54.9%55.2%55.5%55.9%56.2%56.5%56.9%57.2%57.5%57.9%58.2%58.5%58.8%59.2%59.5%59.8%60.2%60.5%60.8%61.2%61.5%61.8%62.1%62.5%62.8%63.1%63.5%63.8%64.1%64.5%64.8%65.1%65.5%65.8%66.1%66.4%66.8%67.1%67.4%67.8%68.1%68.4%68.8%69.1%69.4%69.8%70.1%70.4%70.7%71.1%71.4%71.7%72.1%72.4%72.7%73.1%73.4%73.7%74.0%74.4%74.7%75.0%75.4%75.7%76.0%76.4%76.7%77.0%77.4%77.7%78.0%78.3%78.7%79.0%79.3%79.7%80.0%80.3%80.7%81.0%81.3%81.7%82.0%82.3%82.6%83.0%83.3%83.6%84.0%84.3%84.6%85.0%85.3%85.6%85.9%86.3%86.6%86.9%87.3%87.6%87.9%88.3%88.6%88.9%89.3%89.6%89.9%90.2%90.6%90.9%91.2%91.6%91.9%92.2%92.6%92.9%93.2%93.6%93.9%94.2%94.5%94.9%95.2%95.5%95.9%96.2%96.5%96.9%97.2%97.5%97.9%98.2%98.5%98.8%99.2%99.5%99.8%100.0%\n100.0%\n2.0%4.0%6.0%7.9%9.9%11.9%13.9%15.9%17.9%19.9%21.9%23.8%25.8%27.8%29.8%31.8%33.8%35.8%37.8%39.7%41.7%43.7%45.7%47.7%49.7%51.7%53.7%55.6%57.6%59.6%61.6%63.6%65.6%67.6%69.6%71.5%73.5%75.5%77.5%79.5%81.5%83.5%85.5%87.4%89.4%91.4%93.4%95.4%97.4%99.4%100.0%\n100.0%\n\n\n\n\n\n\n\n\nFigure 1: A batch of example images of handwritten digits."
  },
  {
    "objectID": "projects/20211117_digit_recognizer/index.html#build-a-model",
    "href": "projects/20211117_digit_recognizer/index.html#build-a-model",
    "title": "Digit recognizer",
    "section": "Build a model",
    "text": "Build a model\nWe start off with building a baseline model that simply takes all individual pixels and passes them through a fully connected network.\n\n\nCode\nclass BaselineModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n\n        self.flatten = nn.Flatten()\n        self.linear1 = nn.Linear(in_features=28 * 28, out_features=16)\n        self.linear2 = nn.Linear(in_features=16, out_features=10)\n\n    def forward(self, x):\n        x = self.flatten(x)\n        x = F.relu(self.linear1(x))\n        x = self.linear2(x)\n        return x"
  },
  {
    "objectID": "projects/20211117_digit_recognizer/index.html#train-the-model",
    "href": "projects/20211117_digit_recognizer/index.html#train-the-model",
    "title": "Digit recognizer",
    "section": "Train the model",
    "text": "Train the model\nIn PyTorch we need to make sure that the model and data live on the same device. Obviously, if we can use a GPU to speed up the training, we would do this. Therefore, we first check for the device, and then move the model and data there.\n\n\nCode\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n# Create an instance of the model\nbaseline_model = BaselineModel().to(device)\n\n# Define the loss function to use\nloss_fn = nn.CrossEntropyLoss()\n\n# Use a common optimizer\noptimizer = optim.Adam(baseline_model.parameters(), lr=0.001)\n\n\nWe define a separate function for validation that we can call after each training epoch:\n\n\nCode\ndef eval_step(\n    model: nn.Module,\n    dataloader: DataLoader,\n    loss_fn: nn.Module,\n    device: torch.device\n):\n    # Put the model in eval mode\n    model.eval()\n\n    # Initialize performance metrics\n    running_loss = 0.0\n    correct = 0\n    total = 0\n\n    with torch.no_grad():\n        for features, targets in dataloader:\n            # Put the data and target to the device\n            features, targets = features.to(device), targets.to(device)\n\n            # Make predictions -- forward propagation\n            predictions = model(features)\n\n            # Calculate the loss\n            loss = loss_fn(predictions, targets)\n\n            # Track progress\n            running_loss += loss.item()\n            _, predicted = torch.max(predictions, 1)\n            total += targets.size(0)\n            correct += (predicted == targets).sum().item()\n\n    avg_loss = running_loss / len(dataloader)\n    accuracy = 100. * correct / total\n    return avg_loss, accuracy\n\ndef train_step(\n    model: nn.Module,\n    dataloader: DataLoader,\n    loss_fn: nn.Module,\n    optimizer: optim.Optimizer,\n    device: torch.device\n):\n    # Put the model in training mode\n    model.train()\n\n    # Initialize performance metrics\n    running_loss = 0.0\n    correct = 0\n    total = 0\n\n    for batch_idx, (features, targets) in enumerate(dataloader):\n        # Put the data and targets to the correct device\n        features, targets = features.to(device), targets.to(device)\n\n        # Reset the optimizer\n        optimizer.zero_grad()\n\n        # Make predictions\n        predictions = model(features)\n\n        # Calculate the loss\n        loss = loss_fn(predictions, targets)\n\n        # Calculate the adjustments\n        loss.backward()\n        \n        # Update the model\n        optimizer.step()\n\n        # Track progress\n        running_loss += loss.item()\n        _, predicted = torch.max(predictions, 1)\n        total += targets.size(0)\n        correct += (predicted == targets).sum().item()\n    \n    average_loss = running_loss / len(dataloader)\n    accuracy = 100. * correct / total\n    return average_loss, accuracy\n\n\nNow train the model for several epochs on the training data, and after each epoch get the validation loss and accuracy.\n\n\nCode\nNUM_EPOCHS = 10\n\nhistory = {metric: [] for metric in [\"train_loss\", \"train_acc\", \"val_loss\", \"val_acc\"]}\n\nfor epoch in range(NUM_EPOCHS):\n    train_loss, train_acc = train_step(model=baseline_model, dataloader=train_loader, loss_fn=loss_fn, optimizer=optimizer, device=device)\n    val_loss, val_acc = eval_step(model=baseline_model, dataloader=test_loader, loss_fn=loss_fn, device=device)\n    history[\"train_loss\"].append(train_loss)\n    history[\"train_acc\"].append(train_acc)\n    history[\"val_loss\"].append(val_loss)\n    history[\"val_acc\"].append(val_acc)\nprint(f\"Final validation accuracy: {history['val_acc'][-1]}\")\n\n\nFinal validation accuracy: 95.37\n\n\nWe have to check whether the training has converged and that we are not overfitting.\n\n\nCode\nfig, axs = plt.subplots(1, 2, sharex=True)\naxs[0].plot(np.arange(NUM_EPOCHS) + 1, history[\"train_loss\"], label=\"training\")\naxs[0].plot(np.arange(NUM_EPOCHS) + 1, history[\"val_loss\"], label=\"validation\")\naxs[1].plot(np.arange(NUM_EPOCHS) + 1, history[\"train_acc\"], label=\"training\")\naxs[1].plot(np.arange(NUM_EPOCHS) + 1, history[\"val_acc\"], label=\"validation\")\naxs[0].set_ylabel(\"Loss\")\naxs[0].legend(loc=\"upper right\")\naxs[1].set_ylabel(\"Accuracy\")\naxs[1].legend(loc=\"lower right\")\nfor ax in axs:\n    ax.set_xlabel(\"Epoch\")\nplt.tight_layout()\nplt.show()"
  }
]